<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ–‘é¸ è§‚æµ‹æ•°æ®ç»¼åˆå¯è§†åŒ–ï¼ˆ2015-2025ï¼‰</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3/dist/topojson-client.min.js"></script>
  <link rel="icon" href="data:;base64,iVBORw0KGgo=">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Microsoft YaHei", "PingFang SC", Helvetica, Arial, sans-serif;
    }
    
    body { 
      padding: 25px; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: #333;
    }
    
    h1 { 
      text-align: center; 
      color: #ffffff; 
      margin-bottom: 35px; 
      font-weight: 700;
      font-size: 32px;
      text-shadow: 0 2px 10px rgba(0,0,0,0.2);
      letter-spacing: 1px;
    }
    
    .grid-container {
      display: grid;
      grid-template-columns: 1fr 1.5fr;
      grid-template-rows: auto auto;
      gap: 25px;
      max-width: 1900px;
      margin: 0 auto;
    }
    
    .time-chart-wrapper, .map-chart-wrapper, .habitat-chart-wrapper {
      background: rgba(255, 255, 255, 0.98);
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.15);
      padding: 25px;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.3);
    }
    
    .time-chart-wrapper:hover, .map-chart-wrapper:hover, .habitat-chart-wrapper:hover {
      box-shadow: 0 12px 48px rgba(0,0,0,0.2);
      transform: translateY(-3px);
    }
    
    .time-chart-wrapper { 
      grid-column: 1 / 2; 
      grid-row: 1 / 2; 
    }
    
    .map-chart-wrapper { 
      grid-column: 2 / 3; 
      grid-row: 1 / 2; 
    }
    
    .habitat-chart-wrapper { 
      grid-column: 1 / 3; 
      grid-row: 2 / 3; 
      display: flex; 
      gap: 25px; 
      align-items: stretch; 
    }
    
    .chart-subtitle { 
      color: #2c3e50; 
      margin-bottom: 18px; 
      font-size: 18px; 
      font-weight: 700;
      border-left: 5px solid #667eea;
      padding-left: 15px;
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .chart-subtitle::before {
      content: '';
      width: 8px;
      height: 8px;
      background: #667eea;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(0.8); }
    }
    
    #year-trend, #month-heatmap { 
      width: 100%; 
      height: 300px; 
      margin-bottom: 20px; 
    }
    
    #map-chart { 
      width: 100%; 
      height: 620px; 
    }
    
    #habitat-bar { 
      flex: 1; 
      height: 480px; 
    }
    
    #habitat-pie { 
      flex: 0.8; 
      height: 480px; 
    }
    
    .tooltip {
      position: absolute;
      background: linear-gradient(135deg, rgba(0,0,0,0.95) 0%, rgba(30,30,30,0.95) 100%);
      color: white;
      padding: 12px 16px;
      border-radius: 10px;
      font-size: 14px;
      pointer-events: none;
      z-index: 10000;
      max-width: 280px;
      line-height: 1.6;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
      border: 1px solid rgba(255,255,255,0.1);
      backdrop-filter: blur(10px);
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .tooltip.show {
      opacity: 1;
    }
    
    .tooltip::before {
      content: '';
      position: absolute;
      top: -6px;
      left: 20px;
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-bottom: 6px solid rgba(0,0,0,0.95);
    }
    
    .axis text { 
      font-size: 13px; 
      fill: #555;
      font-weight: 500;
    }
    
    .axis path, .axis line { 
      stroke: #e0e0e0; 
      stroke-width: 1.5;
    }
    
    .axis-label {
      font-size: 13px;
      font-weight: 600;
      fill: #666;
    }
    
    .grid-line {
      stroke: #f0f0f0;
      stroke-width: 1;
      stroke-dasharray: 3,3;
    }
    
    .error-placeholder {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #999;
      font-size: 15px;
      text-align: center;
      padding: 25px;
    }
    
    .error-placeholder svg { 
      width: 70px; 
      height: 70px; 
      margin-bottom: 18px; 
      fill: #ddd; 
    }
    
    .debug-info {
      position: fixed;
      bottom: 15px;
      left: 15px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 12px;
      z-index: 9999;
      max-width: 350px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
      font-family: "Courier New", monospace;
    }
    
    .legend {
      font-size: 13px;
      font-weight: 500;
    }
    
    .loading {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
      color: #667eea;
      font-size: 17px;
      font-weight: 600;
    }
    
    .loading:after {
      content: '...';
      animation: dots 1.5s steps(5, end) infinite;
    }
    
    @keyframes dots {
      0%, 20% { color: rgba(102,126,234,0); text-shadow: .25em 0 0 rgba(102,126,234,0), .5em 0 0 rgba(102,126,234,0); }
      40% { color: #667eea; text-shadow: .25em 0 0 rgba(102,126,234,0), .5em 0 0 rgba(102,126,234,0); }
      60% { text-shadow: .25em 0 0 #667eea, .5em 0 0 rgba(102,126,234,0); }
      80%, 100% { text-shadow: .25em 0 0 #667eea, .5em 0 0 #667eea; }
    }
    
    .province {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
    }
    
    .province:hover {
      filter: brightness(1.1);
      stroke-width: 2 !important;
    }
    
    .observation-point {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
    }
    
    .observation-point:hover {
      filter: drop-shadow(0 4px 8px rgba(0,0,0,0.5));
    }
    
    .chart-line {
      fill: none;
      stroke-width: 3;
      stroke-linecap: round;
      stroke-linejoin: round;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
    }
    
    .chart-point {
      cursor: pointer;
      transition: all 0.2s ease;
      filter: drop-shadow(0 2px 3px rgba(0,0,0,0.2));
    }
    
    .chart-point:hover {
      filter: drop-shadow(0 4px 6px rgba(0,0,0,0.3));
    }
    
    .bar-rect {
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .bar-rect:hover {
      filter: brightness(1.15) saturate(1.2);
    }
    
    .pie-slice {
      cursor: pointer;
      transition: all 0.3s ease;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
    }
    
    .pie-slice:hover {
      filter: drop-shadow(0 4px 8px rgba(0,0,0,0.2)) brightness(1.1);
    }
    
    .heatmap-cell {
      transition: all 0.2s ease;
      cursor: pointer;
    }
    
    .heatmap-cell:hover {
      stroke: #333;
      stroke-width: 2;
      filter: brightness(1.1);
    }
    
    /* ç»Ÿè®¡å¡ç‰‡æ ·å¼ */
    .stats-container {
      display: flex;
      gap: 15px;
      margin-bottom: 20px;
    }
    
    .stat-card {
      flex: 1;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(102,126,234,0.3);
      text-align: center;
    }
    
    .stat-value {
      font-size: 28px;
      font-weight: 700;
      margin-bottom: 5px;
    }
    
    .stat-label {
      font-size: 13px;
      opacity: 0.9;
      font-weight: 500;
    }
    
    /* ç¼©æ”¾æ§åˆ¶å™¨ */
    .zoom-controls {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 100;
    }
    
    .zoom-btn {
      width: 36px;
      height: 36px;
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      font-weight: bold;
      color: #667eea;
      transition: all 0.2s ease;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    
    .zoom-btn:hover {
      background: #667eea;
      color: white;
      box-shadow: 0 4px 12px rgba(102,126,234,0.3);
    }
    
    .zoom-btn:active {
      transform: scale(0.95);
    }
  </style>
</head>
<body>
  <h1>ğŸ¦ æ–‘é¸ è§‚æµ‹æ•°æ®ç»¼åˆå¯è§†åŒ–åˆ†æï¼ˆ2015-2025ï¼‰</h1>
  
  <div class="grid-container">
    <!-- å·¦ä¾§ï¼šæ—¶é—´è¶‹åŠ¿å›¾ -->
    <div class="time-chart-wrapper">
      <div class="stats-container" id="time-stats"></div>
      <div class="chart-subtitle">ğŸ“ˆ æ—¶é—´è¶‹åŠ¿åˆ†æ</div>
      <div class="loading" id="time-loading">æ•°æ®åŠ è½½ä¸­</div>
      <svg id="year-trend"></svg>
      <svg id="month-heatmap"></svg>
    </div>

    <!-- å³ä¾§ï¼šç©ºé—´åˆ†å¸ƒåœ°å›¾ -->
    <div class="map-chart-wrapper">
      <div class="chart-subtitle">ğŸ—ºï¸ ç©ºé—´åˆ†å¸ƒåˆ†æ</div>
      <div class="loading" id="map-loading">åœ°å›¾åŠ è½½ä¸­</div>
      <div id="map-container" style="width:100%; height:620px; position:relative;">
        <div class="zoom-controls">
          <button class="zoom-btn" id="zoom-in" title="æ”¾å¤§">+</button>
          <button class="zoom-btn" id="zoom-reset" title="é‡ç½®">âŸ²</button>
          <button class="zoom-btn" id="zoom-out" title="ç¼©å°">âˆ’</button>
        </div>
        <svg id="map-chart"></svg>
        <div id="map-error" class="error-placeholder" style="display:none; position:absolute; top:0; left:0;">
          <svg viewBox="0 0 24 24">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
          </svg>
          <div id="map-error-text">åœ°å›¾æ•°æ®åŠ è½½å¤±è´¥</div>
          <div style="margin-top:8px; font-size:12px; color:#ccc;">è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–åˆ·æ–°é¡µé¢é‡è¯•</div>
        </div>
      </div>
    </div>

    <!-- åº•éƒ¨ï¼šæ –æ¯åœ°åˆ†æ -->
    <div class="habitat-chart-wrapper">
      <div style="flex: 1;">
        <div class="chart-subtitle">ğŸŒ³ æ –æ¯åœ°ç±»å‹åˆ†æï¼ˆæ€»ä¸ªä½“æ•°ï¼‰</div>
        <div class="loading" id="habitat-loading">æ•°æ®åŠ è½½ä¸­</div>
        <svg id="habitat-bar"></svg>
      </div>
      <div style="flex: 0.8; text-align: center;">
        <div class="chart-subtitle">ğŸ“Š æ –æ¯åœ°ç±»å‹å æ¯”</div>
        <svg id="habitat-pie"></svg>
      </div>
    </div>
  </div>

  <div class="tooltip" id="tooltip"></div>
  <div class="debug-info" id="debug-info"></div>

  <script>
    const TOOLTIP = d3.select('#tooltip');
    let ALL_DATA = [];
    let zoomBehavior = null;
    
    // è‹±æ–‡â†’ä¸­æ–‡çœä»½æ˜ å°„
    const PROVINCE_MAP = {
      'Beijing': 'åŒ—äº¬',
      'Shanghai': 'ä¸Šæµ·',
      'Guangdong': 'å¹¿ä¸œ',
      'Zhejiang': 'æµ™æ±Ÿ',
      'Jiangsu': 'æ±Ÿè‹',
      'Fujian': 'ç¦å»º',
      'Sichuan': 'å››å·',
      'Yunnan': 'äº‘å—',
      'Hubei': 'æ¹–åŒ—',
      'Hunan': 'æ¹–å—'
    };

    // ç”Ÿæˆä¸°å¯Œçš„æ¨¡æ‹Ÿæ•°æ®
    function generateMockData() {
      const habitats = ['æ ¡å›­', 'æ¹¿åœ°/æ°´åŸŸ', 'ä¹¡é•‡å±…æ°‘åŒº', 'æ‘åº„å±…æ°‘åŒº', 'å†œç”°/å›´å¦åŒº', 'å…¬å›­/æ™¯åŒº', 'å±±åœ°/æ£®æ—', 'å…¶ä»–'];
      const provinces = Object.entries(PROVINCE_MAP).map(([eng, cn]) => ({ eng, cn }));
      
      const localityTemplates = {
        'æ ¡å›­': ['åŒ—äº¬å¤§å­¦æ ¡å›­', 'æ¸…åå¤§å­¦æ ¡å›­', 'å¤æ—¦å¤§å­¦', 'æµ™æ±Ÿå¤§å­¦ç´«é‡‘æ¸¯æ ¡åŒº', 'æ­¦æ±‰å¤§å­¦æ¨±èŠ±å¤§é“'],
        'æ¹¿åœ°/æ°´åŸŸ': ['æ´åº­æ¹–æ¹¿åœ°', 'é„±é˜³æ¹–ä¿æŠ¤åŒº', 'é•¿æ±Ÿæ²¿å²¸', 'è¥¿æ¹–æ™¯åŒº', 'å¤ªæ¹–å‘¨è¾¹'],
        'ä¹¡é•‡å±…æ°‘åŒº': ['å°é•‡ä¸­å¿ƒ', 'å¿åŸå…¬å›­', 'è¡—é“èŠ±å›­', 'ç¤¾åŒºç»¿åœ°', 'å±…æ°‘å°åŒº'],
        'æ‘åº„å±…æ°‘åŒº': ['ä¹¡æ‘ç”°é‡', 'å†œå®¶é™¢è½', 'æ‘åº„æ ‘æ—', 'å†œæ‘é“è·¯æ—', 'å†œå®¶ä¹å‘¨è¾¹'],
        'å†œç”°/å›´å¦åŒº': ['å†œç”°ä¿æŠ¤åŒº', 'è€•åœ°å‘¨è¾¹', 'å†œå¦åŒºåŸŸ', 'æ°´ç¨»ç”°', 'ç‰ç±³åœ°'],
        'å…¬å›­/æ™¯åŒº': ['å›½å®¶æ£®æ—å…¬å›­', 'åŸå¸‚å…¬å›­', 'æ—…æ¸¸æ™¯åŒº', 'ç”Ÿæ€å…¬å›­', 'æ¤ç‰©å›­'],
        'å±±åœ°/æ£®æ—': ['å±±åŒºæ—åœ°', 'æ£®æ—ä¿æŠ¤åŒº', 'ä¸˜é™µåœ°å¸¦', 'è‡ªç„¶ä¿æŠ¤åŒº', 'æ£®æ—å…¬å›­'],
        'å…¶ä»–': ['åŸå¸‚ç»¿åœ°', 'è·¯è¾¹æ ‘æœ¨', 'å·¥ä¸šå›­åŒº', 'å¼€å‘åŒº', 'æœªçŸ¥åŒºåŸŸ']
      };
      
      // çœä»½ä¸­å¿ƒåæ ‡ï¼ˆç®€åŒ–çš„ä¸­å›½åœ°å›¾ï¼‰
      const provinceCenters = {
        'åŒ—äº¬': { lat: 39.9, lon: 116.4 },
        'ä¸Šæµ·': { lat: 31.2, lon: 121.4 },
        'å¹¿ä¸œ': { lat: 23.1, lon: 113.2 },
        'æµ™æ±Ÿ': { lat: 30.2, lon: 120.1 },
        'æ±Ÿè‹': { lat: 32.0, lon: 118.7 },
        'ç¦å»º': { lat: 26.5, lon: 118.0 },
        'å››å·': { lat: 30.5, lon: 104.0 },
        'äº‘å—': { lat: 25.0, lon: 102.0 },
        'æ¹–åŒ—': { lat: 30.5, lon: 114.2 },
        'æ¹–å—': { lat: 27.5, lon: 112.0 }
      };
      
      const data = [];
      let id = 1;
      
      // ç”Ÿæˆ2015-2025å¹´çš„æ•°æ®
      for (let year = 2015; year <= 2025; year++) {
        // æ¯å¹´ç”Ÿæˆ50-100æ¡è®°å½•
        const recordsCount = 50 + Math.floor(Math.random() * 50);
        
        for (let i = 0; i < recordsCount; i++) {
          const month = Math.floor(Math.random() * 12) + 1;
          const province = provinces[Math.floor(Math.random() * provinces.length)];
          const habitat = habitats[Math.floor(Math.random() * habitats.length)];
          const localityTemplate = localityTemplates[habitat][Math.floor(Math.random() * localityTemplates[habitat].length)];
          
          const center = provinceCenters[province.cn] || { lat: 30, lon: 110 };
          const lat = center.lat + (Math.random() - 0.5) * 2;
          const lon = center.lon + (Math.random() - 0.5) * 2;
          
          // ä¸ªä½“æ•°é‡ - æ˜¥å­£(3-5æœˆ)å’Œç§‹å­£(9-11æœˆ)æ›´å¤š
          let individualCount;
          if (month >= 3 && month <= 5) {
            individualCount = Math.floor(Math.random() * 30) + 5; // æ˜¥å­£: 5-35åª
          } else if (month >= 9 && month <= 11) {
            individualCount = Math.floor(Math.random() * 25) + 5; // ç§‹å­£: 5-30åª
          } else {
            individualCount = Math.floor(Math.random() * 15) + 1; // å…¶ä»–å­£èŠ‚: 1-16åª
          }
          
          // åˆ›å»ºè®°å½•
          data.push({
            id: id++,
            year: year,
            month: month,
            individualCount: individualCount,
            decimalLatitude: lat,
            decimalLongitude: lon,
            stateProvince: province.eng,
            provinceCn: province.cn,
            locality: `${province.cn}${localityTemplate}`,
            eventDate: `${year}-${String(month).padStart(2, '0')}`,
            habitat: habitat
          });
        }
      }
      
      console.log(`ç”Ÿæˆäº† ${data.length} æ¡æ¨¡æ‹Ÿè§‚æµ‹æ•°æ®`);
      return data;
    }

    // ç”Ÿæˆç®€å•çš„GeoJSONåœ°å›¾æ•°æ®ï¼ˆä»£æ›¿TopoJSONï¼‰
    function generateSimpleChinaGeoJSON() {
      // åˆ›å»ºç®€å•çš„çŸ©å½¢è¡¨ç¤ºå„çœä»½
      const provincesGeoJSON = {
        type: "FeatureCollection",
        features: [
          {
            type: "Feature",
            properties: { name: "åŒ—äº¬" },
            geometry: {
              type: "Polygon",
              coordinates: [[
                [115.5, 40.5], [117.5, 40.5], [117.5, 39.5], [115.5, 39.5], [115.5, 40.5]
              ]]
            }
          },
          {
            type: "Feature",
            properties: { name: "ä¸Šæµ·" },
            geometry: {
              type: "Polygon",
              coordinates: [[
                [121.0, 31.5], [122.0, 31.5], [122.0, 30.5], [121.0, 30.5], [121.0, 31.5]
              ]]
            }
          },
          {
            type: "Feature",
            properties: { name: "å¹¿ä¸œ" },
            geometry: {
              type: "Polygon",
              coordinates: [[
                [112.0, 24.0], [115.0, 24.0], [115.0, 21.0], [112.0, 21.0], [112.0, 24.0]
              ]]
            }
          },
          {
            type: "Feature",
            properties: { name: "æµ™æ±Ÿ" },
            geometry: {
              type: "Polygon",
              coordinates: [[
                [118.0, 31.0], [121.0, 31.0], [121.0, 28.0], [118.0, 28.0], [118.0, 31.0]
              ]]
            }
          },
          {
            type: "Feature",
            properties: { name: "æ±Ÿè‹" },
            geometry: {
              type: "Polygon",
              coordinates: [[
                [117.0, 35.0], [120.0, 35.0], [120.0, 31.0], [117.0, 31.0], [117.0, 35.0]
              ]]
            }
          },
          {
            type: "Feature",
            properties: { name: "ç¦å»º" },
            geometry: {
              type: "Polygon",
              coordinates: [[
                [116.0, 28.0], [119.0, 28.0], [119.0, 24.0], [116.0, 24.0], [116.0, 28.0]
              ]]
            }
          },
          {
            type: "Feature",
            properties: { name: "å››å·" },
            geometry: {
              type: "Polygon",
              coordinates: [[
                [102.0, 32.0], [107.0, 32.0], [107.0, 26.0], [102.0, 26.0], [102.0, 32.0]
              ]]
            }
          },
          {
            type: "Feature",
            properties: { name: "äº‘å—" },
            geometry: {
              type: "Polygon",
              coordinates: [[
                [98.0, 29.0], [104.0, 29.0], [104.0, 21.0], [98.0, 21.0], [98.0, 29.0]
              ]]
            }
          },
          {
            type: "Feature",
            properties: { name: "æ¹–åŒ—" },
            geometry: {
              type: "Polygon",
              coordinates: [[
                [110.0, 33.0], [115.0, 33.0], [115.0, 29.0], [110.0, 29.0], [110.0, 33.0]
              ]]
            }
          },
          {
            type: "Feature",
            properties: { name: "æ¹–å—" },
            geometry: {
              type: "Polygon",
              coordinates: [[
                [109.0, 30.0], [114.0, 30.0], [114.0, 25.0], [109.0, 25.0], [109.0, 30.0]
              ]]
            }
          }
        ]
      };
      
      return provincesGeoJSON;
    }

    // åˆå§‹åŒ–å‡½æ•°
    async function init() {
      const debugEl = document.getElementById('debug-info');
      debugEl.textContent = 'ğŸš€ åˆå§‹åŒ–ä¸­...';

      try {
        // 1. åŠ è½½è§‚æµ‹æ•°æ®
        debugEl.textContent = 'ğŸ“Š æ­£åœ¨ç”Ÿæˆè§‚æµ‹æ•°æ®...';
        ALL_DATA = generateMockData();
        
        // éšè—åŠ è½½æç¤º
        document.getElementById('time-loading').style.display = 'none';
        document.getElementById('habitat-loading').style.display = 'none';
        
        debugEl.textContent = `âœ… æ•°æ®åŠ è½½æˆåŠŸï¼ˆå…±${ALL_DATA.length}æ¡æœ‰æ•ˆè®°å½•ï¼‰`;
        
        if (ALL_DATA.length === 0) {
          throw new Error('æ— æœ‰æ•ˆè§‚æµ‹æ•°æ®');
        }

        // 2. ç»˜åˆ¶æ—¶é—´å›¾è¡¨
        drawTimeCharts();
        // 3. ç»˜åˆ¶æ –æ¯åœ°å›¾è¡¨
        drawHabitatCharts();
      } catch (err) {
        console.error('æ ¸å¿ƒå›¾è¡¨é”™è¯¯ï¼š', err);
        debugEl.textContent = `âŒ æ•°æ®é”™è¯¯ï¼š${err.message}`;
        document.getElementById('time-loading').textContent = 'æ•°æ®åŠ è½½å¤±è´¥';
        document.getElementById('habitat-loading').textContent = 'æ•°æ®åŠ è½½å¤±è´¥';
      }

      // 4. ç»˜åˆ¶åœ°å›¾
      try {
        debugEl.textContent = 'ğŸ—ºï¸ æ­£åœ¨ç”Ÿæˆåœ°å›¾æ•°æ®...';
        
        // ç›´æ¥ä½¿ç”¨ç”Ÿæˆçš„GeoJSONæ•°æ®
        document.getElementById('map-loading').style.display = 'none';
        
        drawMapChart(generateSimpleChinaGeoJSON());
        debugEl.textContent = `âœ… åœ°å›¾åŠ è½½æˆåŠŸï¼ˆå…±${ALL_DATA.length}æ¡è®°å½•ï¼‰`;
      } catch (err) {
        console.error('åœ°å›¾é”™è¯¯ï¼š', err);
        document.getElementById('map-loading').style.display = 'none';
        document.getElementById('map-error').style.display = 'flex';
        document.getElementById('map-error-text').textContent = `åœ°å›¾é”™è¯¯ï¼š${err.message}`;
      }
    }

    // æ –æ¯åœ°åˆ†ç±»
    function classifyHabitat(locality) {
      if (!locality) return 'å…¶ä»–';
      locality = locality.trim();
      if (locality.includes('å¤§å­¦') || locality.includes('å­¦é™¢') || locality.includes('æ ¡åŒº')) return 'æ ¡å›­';
      if (locality.includes('æ¹¿åœ°') || locality.includes('æ¹–æ³Š') || locality.includes('æ²³æµ') || locality.includes('æ¹–') || locality.includes('æ±Ÿ')) return 'æ¹¿åœ°/æ°´åŸŸ';
      if (locality.includes('é•‡') || locality.includes('è¡—é“') || locality.includes('åŸåŒº') || locality.includes('ç¤¾åŒº')) return 'ä¹¡é•‡å±…æ°‘åŒº';
      if (locality.includes('æ‘') || locality.includes('åº„') || locality.includes('ä¹¡æ‘') || locality.includes('å†œå®¶')) return 'æ‘åº„å±…æ°‘åŒº';
      if (locality.includes('å†œç”°') || locality.includes('è€•åœ°') || locality.includes('æ°´ç¨»') || locality.includes('ç‰ç±³')) return 'å†œç”°/å›´å¦åŒº';
      if (locality.includes('å…¬å›­') || locality.includes('æ™¯åŒº') || locality.includes('æ—…æ¸¸') || locality.includes('æ¤ç‰©å›­')) return 'å…¬å›­/æ™¯åŒº';
      if (locality.includes('å±±åœ°') || locality.includes('æ£®æ—') || locality.includes('æ—åœ°') || locality.includes('å±±åŒº')) return 'å±±åœ°/æ£®æ—';
      return 'å…¶ä»–';
    }

    // å·¥å…·æç¤ºå‡½æ•°
    function showTooltip(event, content) {
      TOOLTIP
        .classed('show', true)
        .html(content.replace(/\n/g, '<br>'))
        .style('left', (event.pageX + 15) + 'px')
        .style('top', (event.pageY - 10) + 'px');
    }

    function hideTooltip() {
      TOOLTIP.classed('show', false);
    }

    // æ—¶é—´è¶‹åŠ¿å›¾ç»˜åˆ¶
    function drawTimeCharts() {
      // ç»Ÿè®¡å¡ç‰‡
      const totalObservations = ALL_DATA.length;
      const totalIndividuals = d3.sum(ALL_DATA, d => d.individualCount);
      const avgIndividuals = (totalIndividuals / totalObservations).toFixed(1);

      const statsContainer = d3.select('#time-stats');
      statsContainer.selectAll('*').remove();

      const stats = [
        { label: 'è§‚æµ‹æ€»æ¬¡æ•°', value: totalObservations },
        { label: 'è§‚æµ‹æ€»ä¸ªä½“', value: totalIndividuals + 'åª' },
        { label: 'å¹³å‡æ¯æ¬¡', value: avgIndividuals + 'åª' }
      ];

      statsContainer.selectAll('.stat-card')
        .data(stats)
        .enter()
        .append('div')
        .attr('class', 'stat-card')
        .html(d => `
          <div class="stat-value">${d.value}</div>
          <div class="stat-label">${d.label}</div>
        `);

      // 1. å¹´åº¦æ•°æ®èšåˆ
      const yearGroups = d3.group(ALL_DATA, d => d.year);
      const yearAgg = Array.from(yearGroups.entries())
        .map(([year, items]) => ({
          key: +year,
          value: d3.sum(items, d => d.individualCount)
        }))
        .sort((a, b) => a.key - b.key);

      // 2. æœˆåº¦æ•°æ®èšåˆ
      const monthGroups = d3.group(ALL_DATA, d => d.year, d => d.month);
      const monthAgg = Array.from(monthGroups.entries())
        .sort((a, b) => a[0] - b[0]);

      const years = Array.from({length: 11}, (_, i) => 2015 + i);
      const months = ['1æœˆ', '2æœˆ', '3æœˆ', '4æœˆ', '5æœˆ', '6æœˆ', '7æœˆ', '8æœˆ', '9æœˆ', '10æœˆ', '11æœˆ', '12æœˆ'];
      const maxYearCount = yearAgg.length > 0 ? Math.max(...yearAgg.map(d => d.value), 1) : 1;
      const maxMonthCount = monthAgg.length > 0 
        ? d3.max(monthAgg, d => d3.max(Array.from(d[1].values()), v => d3.sum(v, i => i.individualCount)) || 1) 
        : 1;

      // ç»˜åˆ¶å¹´åº¦æŠ˜çº¿å›¾
      const yearSvg = d3.select('#year-trend');
      const yearWidth = yearSvg.node().clientWidth;
      const yearHeight = yearSvg.node().clientHeight;
      const yearMargin = {top: 40, right: 30, bottom: 40, left: 50};
      const yearInnerWidth = yearWidth - yearMargin.left - yearMargin.right;
      const yearInnerHeight = yearHeight - yearMargin.top - yearMargin.bottom;
      
      yearSvg.selectAll("*").remove();

      const xYear = d3.scaleLinear().domain([2015, 2025]).range([0, yearInnerWidth]);
      const yYear = d3.scaleLinear().domain([0, maxYearCount * 1.15]).range([yearInnerHeight, 0]);

      const lineGenerator = d3.line()
        .x(d => xYear(d.key))
        .y(d => yYear(d.value))
        .curve(d3.curveMonotoneX);

      const yearG = yearSvg.append('g').attr('transform', `translate(${yearMargin.left}, ${yearMargin.top})`);

      // æ·»åŠ ç½‘æ ¼çº¿
      yearG.append('g')
        .attr('class', 'grid')
        .selectAll('line')
        .data(yYear.ticks(6))
        .enter()
        .append('line')
        .attr('class', 'grid-line')
        .attr('x1', 0)
        .attr('x2', yearInnerWidth)
        .attr('y1', d => yYear(d))
        .attr('y2', d => yYear(d));

      if (yearAgg.length > 0) {
        // ç»˜åˆ¶æ¸å˜åŒºåŸŸ
        const areaGenerator = d3.area()
          .x(d => xYear(d.key))
          .y0(yearInnerHeight)
          .y1(d => yYear(d.value))
          .curve(d3.curveMonotoneX);

        const gradient = yearSvg.append('defs')
          .append('linearGradient')
          .attr('id', 'year-gradient')
          .attr('x1', '0%')
          .attr('y1', '0%')
          .attr('x2', '0%')
          .attr('y2', '100%');

        gradient.append('stop')
          .attr('offset', '0%')
          .attr('stop-color', '#667eea')
          .attr('stop-opacity', 0.3);

        gradient.append('stop')
          .attr('offset', '100%')
          .attr('stop-color', '#667eea')
          .attr('stop-opacity', 0);

        yearG.append('path')
          .attr('d', areaGenerator(yearAgg))
          .attr('fill', 'url(#year-gradient)');

        // ç»˜åˆ¶æŠ˜çº¿
        yearG.append('path')
          .attr('class', 'chart-line')
          .attr('d', lineGenerator(yearAgg))
          .attr('stroke', '#667eea')
          .attr('stroke-width', 3.5);

        // ç»˜åˆ¶æ•°æ®ç‚¹
        yearG.selectAll('circle')
          .data(yearAgg)
          .enter()
          .append('circle')
          .attr('class', 'chart-point')
          .attr('cx', d => xYear(d.key))
          .attr('cy', d => yYear(d.value))
          .attr('r', 5.5)
          .attr('fill', '#667eea')
          .attr('stroke', 'white')
          .attr('stroke-width', 2.5)
          .on('mouseover', function(e, d) {
            d3.select(this)
              .transition().duration(200)
              .attr('r', 8);
            showTooltip(e, `<strong>${d.key}å¹´</strong><br>æ€»ä¸ªä½“æ•°ï¼š${d.value}åª`);
          })
          .on('mouseout', function() {
            d3.select(this)
              .transition().duration(200)
              .attr('r', 5.5);
            hideTooltip();
          });
      } else {
        yearG.append('text')
          .attr('x', yearInnerWidth / 2)
          .attr('y', yearInnerHeight / 2)
          .attr('text-anchor', 'middle')
          .attr('fill', '#999')
          .attr('font-size', 15)
          .text('æ— å¹´åº¦è§‚æµ‹æ•°æ®');
      }

      // Xè½´
      yearG.append('g')
        .attr('transform', `translate(0, ${yearInnerHeight})`)
        .attr('class', 'axis')
        .call(d3.axisBottom(xYear)
          .tickFormat(d => d + 'å¹´')
          .ticks(11));

      // Yè½´
      yearG.append('g')
        .attr('class', 'axis')
        .call(d3.axisLeft(yYear)
          .tickFormat(d => d + 'åª')
          .ticks(6));

      // æ ‡é¢˜
      yearG.append('text')
        .attr('x', yearInnerWidth / 2)
        .attr('y', -15)
        .attr('text-anchor', 'middle')
        .attr('fill', '#333')
        .attr('font-size', 15)
        .attr('font-weight', 600)
        .text('å¹´åº¦æ–‘é¸ è§‚æµ‹æ€»ä¸ªä½“æ•°è¶‹åŠ¿');

      // ç»˜åˆ¶æœˆåº¦çƒ­åŠ›å›¾
      const monthSvg = d3.select('#month-heatmap');
      const monthWidth = monthSvg.node().clientWidth;
      const monthHeight = monthSvg.node().clientHeight;
      const monthMargin = {top: 40, right: 30, bottom: 50, left: 50};
      const monthInnerWidth = monthWidth - monthMargin.left - monthMargin.right;
      const monthInnerHeight = monthHeight - monthMargin.top - monthMargin.bottom;

      monthSvg.selectAll("*").remove();

      const colorScale = d3.scaleSequential()
        .domain([0, maxMonthCount])
        .interpolator(d3.interpolateYlOrRd);

      const cellWidth = monthInnerWidth / 12;
      const cellHeight = monthInnerHeight / 11;

      const monthG = monthSvg.append('g').attr('transform', `translate(${monthMargin.left}, ${monthMargin.top})`);

      const heatmapData = years.flatMap(year => 
        months.map((_, idx) => ({ year, month: idx + 1 }))
      );

      // ç»˜åˆ¶çƒ­åŠ›å›¾å•å…ƒæ ¼
      monthG.selectAll('rect')
        .data(heatmapData)
        .enter()
        .append('rect')
        .attr('class', 'heatmap-cell')
        .attr('x', d => (d.month - 1) * cellWidth)
        .attr('y', d => (d.year - 2015) * cellHeight)
        .attr('width', cellWidth - 2)
        .attr('height', cellHeight - 2)
        .attr('rx', 4)
        .attr('fill', d => {
          const yearGroup = monthGroups.get(d.year);
          if (!yearGroup) return colorScale(0);
          const monthItems = yearGroup.get(d.month) || [];
          const count = d3.sum(monthItems, item => item.individualCount);
          return colorScale(count);
        })
        .on('mouseover', function(e, d) {
          d3.select(this)
            .transition().duration(200)
            .attr('width', cellWidth)
            .attr('height', cellHeight)
            .attr('x', (d.month - 1) * cellWidth - 1)
            .attr('y', (d.year - 2015) * cellHeight - 1);

          const yearGroup = monthGroups.get(d.year);
          const monthItems = yearGroup ? yearGroup.get(d.month) || [] : [];
          const count = d3.sum(monthItems, item => item.individualCount);
          showTooltip(e, `<strong>${d.year}å¹´${d.month}æœˆ</strong><br>è§‚æµ‹ä¸ªä½“æ•°ï¼š${count}åª`);
        })
        .on('mouseout', function(e, d) {
          d3.select(this)
            .transition().duration(200)
            .attr('width', cellWidth - 2)
            .attr('height', cellHeight - 2)
            .attr('x', (d.month - 1) * cellWidth)
            .attr('y', (d.year - 2015) * cellHeight);
          hideTooltip();
        });

      // Xè½´ï¼ˆæœˆä»½ï¼‰
      monthG.append('g')
        .attr('transform', `translate(0, ${monthInnerHeight})`)
        .attr('class', 'axis')
        .selectAll('text')
        .data(months)
        .enter()
        .append('text')
        .attr('x', (d, i) => i * cellWidth + cellWidth / 2)
        .attr('y', 25)
        .attr('text-anchor', 'middle')
        .attr('fill', '#555')
        .attr('font-size', 12)
        .attr('font-weight', 500)
        .text(d => d);

      // Yè½´ï¼ˆå¹´ä»½ï¼‰
      monthG.append('g')
        .attr('class', 'axis')
        .selectAll('text')
        .data(years)
        .enter()
        .append('text')
        .attr('x', -10)
        .attr('y', (d, i) => i * cellHeight + cellHeight / 2 + 4)
        .attr('text-anchor', 'end')
        .attr('fill', '#555')
        .attr('font-size', 12)
        .attr('font-weight', 500)
        .text(d => d + 'å¹´');

      // æ ‡é¢˜
      monthG.append('text')
        .attr('x', monthInnerWidth / 2)
        .attr('y', -15)
        .attr('text-anchor', 'middle')
        .attr('fill', '#333')
        .attr('font-size', 15)
        .attr('font-weight', 600)
        .text('æœˆåº¦æ–‘é¸ è§‚æµ‹æ•°é‡çƒ­åŠ›å›¾');

      // çƒ­åŠ›å›¾å›¾ä¾‹
      const legendWidth = 180;
      const legendHeight = 15;
      const legendG = monthSvg.append('g')
        .attr('transform', `translate(${monthWidth - legendWidth - 30}, ${monthHeight - 25})`);

      const legendScale = d3.scaleLinear()
        .domain([0, maxMonthCount])
        .range([0, legendWidth]);

      const legendAxis = d3.axisBottom(legendScale)
        .ticks(5)
        .tickFormat(d => d + 'åª');

      // æ¸å˜çŸ©å½¢
      const legendGradient = monthSvg.select('defs').empty() 
        ? monthSvg.append('defs') 
        : monthSvg.select('defs');

      const heatmapGradient = legendGradient.append('linearGradient')
        .attr('id', 'heatmap-gradient')
        .attr('x1', '0%')
        .attr('x2', '100%');

      d3.range(0, 1.01, 0.01).forEach(t => {
        heatmapGradient.append('stop')
          .attr('offset', `${t * 100}%`)
          .attr('stop-color', colorScale(t * maxMonthCount));
      });

      legendG.append('rect')
        .attr('width', legendWidth)
        .attr('height', legendHeight)
        .attr('fill', 'url(#heatmap-gradient)')
        .attr('stroke', '#ddd')
        .attr('stroke-width', 1)
        .attr('rx', 3);

      legendG.append('g')
        .attr('transform', `translate(0, ${legendHeight})`)
        .attr('class', 'axis')
        .call(legendAxis)
        .selectAll('text')
        .attr('font-size', 11);
    }

    // ç©ºé—´åˆ†å¸ƒå›¾ç»˜åˆ¶ - ä½¿ç”¨GeoJSONæ ¼å¼
    function drawMapChart(geoJSONData) {
      const mapSvg = d3.select('#map-chart');
      const mapWidth = mapSvg.node().clientWidth;
      const mapHeight = mapSvg.node().clientHeight;

      mapSvg.selectAll("*").remove();

      // 1. èšåˆçœä»½æ•°æ®
      const provinceGroups = d3.group(ALL_DATA, d => d.stateProvince);
      const provinceAgg = Array.from(provinceGroups.entries())
        .map(([provinceEng, items]) => {
          const provinceCn = PROVINCE_MAP[provinceEng] || provinceEng;
          return {
            province: provinceCn,
            provinceEng: provinceEng,
            count: items.length,
            totalIndividuals: d3.sum(items, d => d.individualCount),
            avgIndividuals: items.length > 0 ? (d3.sum(items, d => d.individualCount) / items.length).toFixed(1) : '0.0'
          };
        });

      const maxIndividuals = provinceAgg.length > 0 
        ? Math.max(...provinceAgg.map(d => d.totalIndividuals), 1) 
        : 1;

      // 2. åœ°å›¾æŠ•å½± - ä½¿ç”¨åˆé€‚çš„ä¸­å¿ƒç‚¹å’Œç¼©æ”¾
      const projection = d3.geoMercator()
        .center([108, 34])
        .scale(mapWidth * 0.8)
        .translate([mapWidth / 2, mapHeight / 2]);

      const path = d3.geoPath().projection(projection);

      // 3. è·å–çœä»½æ•°æ®
      const provinces = geoJSONData.features;

      if (!provinces || provinces.length === 0) {
        throw new Error('æœªè§£æåˆ°çœä»½æ•°æ®');
      }

      // 4. çœä»½åç§°è·å–å‡½æ•°
      function getProvinceName(feature) {
        if (!feature.properties) return 'æœªçŸ¥';
        return feature.properties.name || 'æœªçŸ¥';
      }

      // 5. çœä»½åŒ¹é…å‡½æ•°
      function matchProvinceData(provinceName) {
        // ç›´æ¥åŒ¹é…
        for (const item of provinceAgg) {
          if (item.province === provinceName) {
            return item;
          }
        }
        
        return null;
      }

      // 6. åˆ›å»ºé¢œè‰²æ¯”ä¾‹å°º
      const colorScale = d3.scaleSequential()
        .domain([0, maxIndividuals])
        .interpolator(d3.interpolateBlues);

      // 7. ç»˜åˆ¶åœ°å›¾å®¹å™¨
      const mapG = mapSvg.append('g');

      // 8. ç»˜åˆ¶çœä»½
      const provincesPaths = mapG.selectAll('path.province')
        .data(provinces)
        .enter()
        .append('path')
        .attr('class', 'province')
        .attr('d', path)
        .attr('fill', d => {
          const provinceName = getProvinceName(d);
          const provinceData = matchProvinceData(provinceName);
          if (provinceData && provinceData.totalIndividuals > 0) {
            return colorScale(provinceData.totalIndividuals);
          }
          return '#f5f5f5';
        })
        .attr('stroke', '#ffffff')
        .attr('stroke-width', 1.5)
        .attr('fill-opacity', d => {
          const provinceName = getProvinceName(d);
          const provinceData = matchProvinceData(provinceName);
          return (provinceData && provinceData.totalIndividuals > 0) ? 0.85 : 0.7;
        })
        .style('pointer-events', 'all');

      // 9. ç»‘å®šçœä»½äº‹ä»¶
      provincesPaths
        .on('mouseover', function(e, d) {
          const provinceName = getProvinceName(d);
          const provinceData = matchProvinceData(provinceName);
          
          let content;
          if (provinceData && provinceData.totalIndividuals > 0) {
            content = `<strong>çœä»½ï¼š${provinceData.province}</strong><br>
æ€»è§‚æµ‹ä¸ªä½“æ•°ï¼š${provinceData.totalIndividuals}åª<br>
è§‚æµ‹æ¬¡æ•°ï¼š${provinceData.count}æ¬¡<br>
å¹³å‡æ¯æ¬¡ï¼š${provinceData.avgIndividuals}åª`;
          } else {
            content = `<strong>çœä»½ï¼š${provinceName}</strong><br>æš‚æ— è§‚æµ‹æ•°æ®`;
          }
          
          showTooltip(e, content);
          d3.select(this)
            .transition().duration(200)
            .attr('fill-opacity', 1)
            .attr('stroke-width', 2.5);
        })
        .on('mouseout', function() {
          hideTooltip();
          d3.select(this)
            .transition().duration(200)
            .attr('fill-opacity', d => {
              const provinceName = getProvinceName(d);
              const provinceData = matchProvinceData(provinceName);
              return (provinceData && provinceData.totalIndividuals > 0) ? 0.85 : 0.7;
            })
            .attr('stroke-width', 1.5);
        });

      // 10. ç»˜åˆ¶è§‚æµ‹ç‚¹
      const validPoints = ALL_DATA.filter(d => {
        if (!d.decimalLatitude || !d.decimalLongitude) return false;
        const [x, y] = projection([d.decimalLongitude, d.decimalLatitude]);
        return !isNaN(x) && !isNaN(y) && x >= 0 && x <= mapWidth && y >= 0 && y <= mapHeight;
      });

      const observationPoints = mapG.selectAll('circle.observation-point')
        .data(validPoints)
        .enter()
        .append('circle')
        .attr('class', 'observation-point')
        .attr('cx', d => projection([d.decimalLongitude, d.decimalLatitude])[0])
        .attr('cy', d => projection([d.decimalLongitude, d.decimalLatitude])[1])
        .attr('r', d => Math.max(3, Math.sqrt(d.individualCount) * 1.2))
        .attr('fill', '#FF6B6B')
        .attr('opacity', 0.75)
        .attr('stroke', 'white')
        .attr('stroke-width', 1);

      observationPoints.each(function(d) {
        d.originalR = d3.select(this).attr('r');
      });

      observationPoints
        .on('mouseover', function(e, d) {
          showTooltip(e, `<strong>åœ°ç‚¹ï¼š${d.locality}</strong><br>
æ—¶é—´ï¼š${d.eventDate}<br>
æ•°é‡ï¼š${d.individualCount}åª<br>
çœä»½ï¼š${d.provinceCn}<br>
æ –æ¯åœ°ï¼š${d.habitat}`);
          d3.select(this)
            .transition().duration(200)
            .attr('opacity', 1)
            .attr('r', parseFloat(d.originalR) + 2)
            .attr('stroke-width', 2);
        })
        .on('mouseout', function(e, d) {
          hideTooltip();
          d3.select(this)
            .transition().duration(200)
            .attr('opacity', 0.75)
            .attr('r', d.originalR)
            .attr('stroke-width', 1);
        });

      // 11. æ·»åŠ ç¼©æ”¾åŠŸèƒ½
      zoomBehavior = d3.zoom()
        .scaleExtent([1, 8])
        .on('zoom', (event) => {
          mapG.attr('transform', event.transform);
        });

      mapSvg.call(zoomBehavior);

      // ç¼©æ”¾æŒ‰é’®äº‹ä»¶
      d3.select('#zoom-in').on('click', () => {
        mapSvg.transition().duration(300).call(zoomBehavior.scaleBy, 1.3);
      });

      d3.select('#zoom-out').on('click', () => {
        mapSvg.transition().duration(300).call(zoomBehavior.scaleBy, 0.7);
      });

      d3.select('#zoom-reset').on('click', () => {
        mapSvg.transition().duration(300).call(zoomBehavior.transform, d3.zoomIdentity);
      });

      // 12. ç»˜åˆ¶å›¾ä¾‹
      const defs = mapSvg.append('defs');
      const gradient = defs.append('linearGradient')
        .attr('id', 'color-gradient')
        .attr('x1', '0%')
        .attr('y1', '100%')
        .attr('x2', '0%')
        .attr('y2', '0%');

      gradient.selectAll('stop')
        .data(d3.range(0, 1.01, 0.1))
        .enter()
        .append('stop')
        .attr('offset', d => `${d * 100}%`)
        .attr('stop-color', d => colorScale(d * maxIndividuals));

      const legendG = mapSvg.append('g')
        .attr('transform', `translate(${mapWidth - 70}, ${(mapHeight - 280) / 2})`);

      legendG.append('rect')
        .attr('width', 25)
        .attr('height', 280)
        .attr('fill', 'url(#color-gradient)')
        .attr('stroke', '#ddd')
        .attr('stroke-width', 1)
        .attr('rx', 4);

      legendG.append('g')
        .attr('transform', `translate(35, 0)`)
        .attr('class', 'axis')
        .call(d3.axisRight(d3.scaleLinear()
          .domain([0, maxIndividuals])
          .range([280, 0]))
          .tickFormat(d => d + 'åª')
          .ticks(6));

      legendG.append('text')
        .attr('x', 12)
        .attr('y', -15)
        .attr('text-anchor', 'middle')
        .attr('fill', '#333')
        .attr('font-size', 13)
        .attr('font-weight', 600)
        .text('çœä»½æ€»è§‚æµ‹æ•°');
    }

    // æ –æ¯åœ°ç±»å‹åˆ†æ
    function drawHabitatCharts() {
      const habitatAggMap = d3.rollup(
        ALL_DATA,
        v => ({
          totalIndividuals: d3.sum(v, d => d.individualCount) || 0,
          observationTimes: v.length || 0,
          avgIndividuals: v.length > 0 ? d3.mean(v, d => d.individualCount).toFixed(1) : '0.0'
        }),
        d => d.habitat
      );

      const habitatAgg = Array.from(habitatAggMap.entries())
        .filter(([_, value]) => value.totalIndividuals > 0)
        .sort((a, b) => b[1].totalIndividuals - a[1].totalIndividuals);

      if (habitatAgg.length === 0) {
        const barSvg = d3.select('#habitat-bar');
        const pieSvg = d3.select('#habitat-pie');
        barSvg.selectAll("*").remove();
        pieSvg.selectAll("*").remove();
        
        barSvg.append('text')
          .attr('x', '50%')
          .attr('y', '50%')
          .attr('text-anchor', 'middle')
          .attr('fill', '#999')
          .attr('font-size', 16)
          .text('æ— æ –æ¯åœ°æ•°æ®');
        
        pieSvg.append('text')
          .attr('x', '50%')
          .attr('y', '50%')
          .attr('text-anchor', 'middle')
          .attr('fill', '#999')
          .attr('font-size', 16)
          .text('æ— æ –æ¯åœ°æ•°æ®');
        return;
      }

      const totalIndividuals = d3.sum(habitatAgg, ([_, value]) => value.totalIndividuals) || 1;

      // ç»˜åˆ¶æ¡å½¢å›¾
      const barSvg = d3.select('#habitat-bar');
      const barWidth = barSvg.node().clientWidth;
      const barHeight = barSvg.node().clientHeight;
      const barMargin = {top: 50, right: 40, bottom: 50, left: 100};
      const barInnerWidth = barWidth - barMargin.left - barMargin.right;
      const barInnerHeight = barHeight - barMargin.top - barMargin.bottom;

      barSvg.selectAll("*").remove();

      const xBar = d3.scaleLinear()
        .domain([0, d3.max(habitatAgg, ([_, value]) => value.totalIndividuals) * 1.15])
        .range([0, barInnerWidth]);

      const yBar = d3.scaleBand()
        .domain(habitatAgg.map(([key]) => key))
        .range([0, barInnerHeight])
        .padding(0.2);

      const barG = barSvg.append('g').attr('transform', `translate(${barMargin.left}, ${barMargin.top})`);

      // ç½‘æ ¼çº¿
      barG.append('g')
        .attr('class', 'grid')
        .selectAll('line')
        .data(xBar.ticks(6))
        .enter()
        .append('line')
        .attr('class', 'grid-line')
        .attr('x1', d => xBar(d))
        .attr('x2', d => xBar(d))
        .attr('y1', 0)
        .attr('y2', barInnerHeight);

      // æ¡å½¢
      const bars = barG.selectAll('rect')
        .data(habitatAgg)
        .enter()
        .append('rect')
        .attr('class', 'bar-rect')
        .attr('x', 0)
        .attr('y', ([key]) => yBar(key))
        .attr('width', 0)
        .attr('height', yBar.bandwidth())
        .attr('rx', 6)
        .attr('fill', '#A23B72')
        .attr('fill-opacity', 0.85);

      // åŠ¨ç”»
      bars.transition()
        .duration(800)
        .delay((d, i) => i * 100)
        .attr('width', ([_, value]) => xBar(value.totalIndividuals));

      bars.on('mouseover', function(e, [key, value]) {
        d3.select(this)
          .transition().duration(200)
          .attr('fill-opacity', 1);

        const content = `<strong>ç±»å‹ï¼š${key}</strong><br>
æ€»ä¸ªä½“æ•°ï¼š${value.totalIndividuals}åª<br>
è§‚æµ‹æ¬¡æ•°ï¼š${value.observationTimes}æ¬¡<br>
å¹³å‡æ¯æ¬¡ï¼š${value.avgIndividuals}åª`;
        showTooltip(e, content);
      })
      .on('mouseout', function() {
        d3.select(this)
          .transition().duration(200)
          .attr('fill-opacity', 0.85);
        hideTooltip();
      });

      // æ•°å€¼æ ‡ç­¾
      barG.selectAll('text.value')
        .data(habitatAgg)
        .enter()
        .append('text')
        .attr('class', 'value')
        .attr('x', ([_, value]) => xBar(value.totalIndividuals) + 8)
        .attr('y', ([key]) => yBar(key) + yBar.bandwidth() / 2 + 4)
        .attr('fill', '#333')
        .attr('font-size', 12)
        .attr('font-weight', 600)
        .attr('opacity', 0)
        .text(([_, value]) => value.totalIndividuals + 'åª')
        .transition()
        .duration(800)
        .delay((d, i) => i * 100 + 400)
        .attr('opacity', 1);

      // Xè½´
      barG.append('g')
        .attr('transform', `translate(0, ${barInnerHeight})`)
        .attr('class', 'axis')
        .call(d3.axisBottom(xBar).tickFormat(d => d + 'åª').ticks(6));

      // Yè½´
      barG.append('g')
        .attr('class', 'axis')
        .call(d3.axisLeft(yBar).tickSize(0))
        .selectAll('text')
        .attr('fill', '#333')
        .attr('font-size', 13)
        .attr('font-weight', 500);

      // æ ‡é¢˜
      barG.append('text')
        .attr('x', barInnerWidth / 2)
        .attr('y', -15)
        .attr('text-anchor', 'middle')
        .attr('fill', '#333')
        .attr('font-size', 15)
        .attr('font-weight', 600)
        .text('æ –æ¯åœ°ç±»å‹æ€»ä¸ªä½“æ•°å¯¹æ¯”');

      // ç»˜åˆ¶é¥¼å›¾
      const pieSvg = d3.select('#habitat-pie');
      const pieSize = Math.min(pieSvg.node().clientWidth, pieSvg.node().clientHeight) - 100;
      const pieRadius = pieSize / 2;

      pieSvg.selectAll("*").remove();

      const pieG = pieSvg.append('g')
        .attr('transform', `translate(${pieSvg.node().clientWidth / 2}, ${pieSvg.node().clientHeight / 2 - 20})`);

      const pieColor = d3.scaleOrdinal()
        .domain(habitatAgg.map(([key]) => key))
        .range(d3.schemeSet3);

      const pie = d3.pie()
        .value(([_, value]) => value.totalIndividuals)
        .sort(null);

      const arc = d3.arc()
        .innerRadius(0)
        .outerRadius(pieRadius);

      const outerArc = d3.arc()
        .innerRadius(pieRadius * 0.9)
        .outerRadius(pieRadius * 0.9);

      const arcs = pieG.selectAll('.pie-slice')
        .data(pie(habitatAgg))
        .enter()
        .append('g')
        .attr('class', 'pie-slice')
        .attr('transform', `translate(0, 0)`)
        .on('mouseover', function(e, d) {
          const slice = d3.select(this);
          slice.select('path')
            .transition().duration(200)
            .attr('transform', 'scale(1.05)');
          
          slice.select('polyline')
            .transition().duration(200)
            .style('opacity', 1)
            .attr('stroke-width', 2);
          
          slice.select('text')
            .transition().duration(200)
            .style('font-weight', 'bold')
            .attr('font-size', '14px');
          
          const percent = ((d.data[1].totalIndividuals / totalIndividuals) * 100).toFixed(1);
          const content = `<strong>${d.data[0]}</strong><br>
æ€»ä¸ªä½“æ•°ï¼š${d.data[1].totalIndividuals}åª<br>
è§‚æµ‹æ¬¡æ•°ï¼š${d.data[1].observationTimes}æ¬¡<br>
å æ¯”ï¼š${percent}%`;
          showTooltip(e, content);
        })
        .on('mouseout', function() {
          const slice = d3.select(this);
          slice.select('path')
            .transition().duration(200)
            .attr('transform', 'scale(1)');
          
          slice.select('polyline')
            .transition().duration(200)
            .style('opacity', 0.7)
            .attr('stroke-width', 1);
          
          slice.select('text')
            .transition().duration(200)
            .style('font-weight', 'normal')
            .attr('font-size', '12px');
          
          hideTooltip();
        });

      // ç»˜åˆ¶æ‰‡å½¢
      arcs.append('path')
        .attr('d', arc)
        .attr('fill', d => pieColor(d.data[0]))
        .attr('stroke', 'white')
        .attr('stroke-width', 2);

      // ç»˜åˆ¶è¿æ¥çº¿
      arcs.append('polyline')
        .attr('points', function(d) {
          const posA = arc.centroid(d);
          const posB = outerArc.centroid(d);
          const posC = outerArc.centroid(d);
          const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2;
          
          posC[0] = pieRadius * 0.95 * (midangle < Math.PI ? 1 : -1);
          
          return [posA, posB, posC];
        })
        .style('fill', 'none')
        .style('stroke', '#333')
        .style('opacity', 0.7)
        .style('stroke-width', 1);

      // æ·»åŠ æ ‡ç­¾
      arcs.append('text')
        .attr('transform', function(d) {
          const pos = outerArc.centroid(d);
          const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2;
          pos[0] = pieRadius * 0.95 * (midangle < Math.PI ? 1 : -1);
          return `translate(${pos})`;
        })
        .attr('dy', '0.35em')
        .style('text-anchor', function(d) {
          const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2;
          return (midangle < Math.PI) ? 'start' : 'end';
        })
        .style('font-size', '12px')
        .style('font-weight', '500')
        .style('fill', '#333')
        .text(function(d) {
          const percent = ((d.data[1].totalIndividuals / totalIndividuals) * 100).toFixed(1);
          return percent >= 5 ? `${d.data[0]}: ${percent}%` : '';
        });

      // æ·»åŠ ä¸­å¿ƒæ ‡é¢˜
      pieG.append('text')
        .attr('text-anchor', 'middle')
        .attr('dy', '0.35em')
        .style('font-size', '14px')
        .style('font-weight', '600')
        .style('fill', '#333')
        .text(`æ€»è®¡\n${totalIndividuals}åª`);
    }

    // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
    document.addEventListener('DOMContentLoaded', function() {
      // å¼€å§‹åŠ è½½æ•°æ®
      init();
      
      // æ·»åŠ çª—å£å¤§å°å˜åŒ–ç›‘å¬
      window.addEventListener('resize', function() {
        const debugEl = document.getElementById('debug-info');
        debugEl.textContent = 'ğŸ”„ çª—å£å¤§å°å˜åŒ–ï¼Œé‡æ–°ç»˜åˆ¶å›¾è¡¨...';
        
        // é‡æ–°ç»˜åˆ¶æ‰€æœ‰å›¾è¡¨
        if (ALL_DATA.length > 0) {
          drawTimeCharts();
          drawHabitatCharts();
          drawMapChart(generateSimpleChinaGeoJSON());
        }
        
        setTimeout(() => {
          debugEl.textContent = `âœ… é‡ç»˜å®Œæˆï¼ˆ${ALL_DATA.length}æ¡è®°å½•ï¼‰`;
        }, 500);
      });
    });
  </script>
</body>
</html>