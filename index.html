<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>斑鸠观测数据综合可视化（2015-2025）</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3/dist/topojson-client.min.js"></script>
  <link rel="icon" href="data:;base64,iVBORw0KGgo=">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: "Microsoft YaHei", Arial, sans-serif;
    }
    body { 
      padding: 20px; 
      background-color: #f9f9f9; 
      color: #333;
    }
    h1 { 
      text-align: center; 
      color: #2c3e50; 
      margin-bottom: 30px; 
      font-weight: 600;
    }
    .grid-container {
      display: grid;
      grid-template-columns: 1fr 1.5fr;
      grid-template-rows: auto auto;
      gap: 20px;
      max-width: 1800px;
      margin: 0 auto;
    }
    .time-chart-wrapper, .map-chart-wrapper, .habitat-chart-wrapper {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      padding: 15px;
      transition: box-shadow 0.3s ease;
    }
    .time-chart-wrapper:hover, .map-chart-wrapper:hover, .habitat-chart-wrapper:hover {
      box-shadow: 0 4px 12px rgba(0,0,0,0.12);
    }
    .time-chart-wrapper { 
      grid-column: 1 / 2; 
      grid-row: 1 / 2; 
    }
    .map-chart-wrapper { 
      grid-column: 2 / 3; 
      grid-row: 1 / 2; 
    }
    .habitat-chart-wrapper { 
      grid-column: 1 / 3; 
      grid-row: 2 / 3; 
      display: flex; 
      gap: 20px; 
      align-items: center; 
    }
    .chart-subtitle { 
      color: #2c3e50; 
      margin-bottom: 10px; 
      font-size: 16px; 
      font-weight: 600;
      border-left: 4px solid #3498db;
      padding-left: 10px;
    }
    #year-trend, #month-heatmap { 
      width: 100%; 
      height: 280px; 
      margin-bottom: 15px; 
    }
    #map-chart { 
      width: 100%; 
      height: 580px; 
    }
    #habitat-bar { 
      flex: 1; 
      height: 450px; 
    }
    #habitat-pie { 
      flex: 0.8; 
      height: 450px; 
    }
    .tooltip {
      position: absolute;
      background: rgba(0,0,0,0.85);
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
      pointer-events: none;
      z-index: 1000;
      max-width: 250px;
      line-height: 1.4;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    .axis text { 
      font-size: 12px; 
      fill: #666; 
    }
    .axis path, .axis line { 
      stroke: #ddd; 
    }
    .error-placeholder {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #999;
      font-size: 14px;
      text-align: center;
      padding: 20px;
    }
    .error-placeholder svg { 
      width: 60px; 
      height: 60px; 
      margin-bottom: 15px; 
      fill: #ddd; 
    }
    .debug-info {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 9999;
      max-width: 300px;
    }
    .legend {
      font-size: 12px;
    }
    .loading {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
      color: #666;
      font-size: 16px;
    }
    .loading:after {
      content: '...';
      animation: dots 1.5s steps(5, end) infinite;
    }
    @keyframes dots {
      0%, 20% { color: rgba(0,0,0,0); text-shadow: .25em 0 0 rgba(0,0,0,0), .5em 0 0 rgba(0,0,0,0); }
      40% { color: #666; text-shadow: .25em 0 0 rgba(0,0,0,0), .5em 0 0 rgba(0,0,0,0); }
      60% { text-shadow: .25em 0 0 #666, .5em 0 0 rgba(0,0,0,0); }
      80%, 100% { text-shadow: .25em 0 0 #666, .5em 0 0 #666; }
    }
    /* 省份和观测点样式 */
    .province {
      transition: fill-opacity 0.3s ease;
    }
    .province:hover {
      fill-opacity: 0.9;
    }
    .observation-point {
      transition: opacity 0.2s ease;
    }
  </style>
</head>
<body>
  <h1>斑鸠观测数据综合可视化分析（2015-2025）</h1>
  
  <div class="grid-container">
    <!-- 左侧：时间趋势图 -->
    <div class="time-chart-wrapper">
      <div class="chart-subtitle">1. 时间趋势分析</div>
      <div class="loading" id="time-loading">数据加载中</div>
      <svg id="year-trend"></svg>
      <svg id="month-heatmap"></svg>
    </div>

    <!-- 右侧：空间分布地图 -->
    <div class="map-chart-wrapper">
      <div class="chart-subtitle">2. 空间分布分析</div>
      <div class="loading" id="map-loading">地图加载中</div>
      <div id="map-container" style="width:100%; height:580px; position:relative;">
        <svg id="map-chart"></svg>
        <div id="map-error" class="error-placeholder" style="display:none; position:absolute; top:0; left:0;">
          <svg viewBox="0 0 24 24">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
          </svg>
          <div id="map-error-text">地图数据加载失败</div>
          <div style="margin-top:8px; font-size:12px; color:#ccc;">请检查网络连接或刷新页面重试</div>
        </div>
      </div>
    </div>

    <!-- 底部：栖息地分析 -->
    <div class="habitat-chart-wrapper">
      <div style="flex: 1;">
        <div class="chart-subtitle">3. 栖息地类型分析（总个体数）</div>
        <div class="loading" id="habitat-loading">数据加载中</div>
        <svg id="habitat-bar"></svg>
      </div>
      <div style="flex: 0.8; text-align: center;">
        <div class="chart-subtitle">栖息地类型占比</div>
        <svg id="habitat-pie"></svg>
      </div>
    </div>
  </div>

  <div class="tooltip" id="tooltip" style="display: none;"></div>
  <div class="debug-info" id="debug-info"></div>

  <script>
    const TOOLTIP = d3.select('#tooltip');
    let ALL_DATA = [];
    
    // 英文→中文省份映射
    const PROVINCE_MAP = {
      'Fujian': '福建', 'Jiangsu': '江苏', 'Tianjin': '天津', 'Hubei': '湖北', 'Yunnan': '云南', 
      'Hebei': '河北', 'Guangdong': '广东', 'Sichuan': '四川', 'Zhejiang': '浙江', 'Shandong': '山东', 
      'Henan': '河南', 'Shanxi': '山西', 'Shaanxi': '陕西', 'Gansu': '甘肃', 'Qinghai': '青海', 
      'Xinjiang': '新疆', 'Tibet': '西藏', 'Inner Mongolia': '内蒙古', 'Ningxia': '宁夏', 'Guangxi': '广西', 
      'Guizhou': '贵州', 'Hunan': '湖南', 'Jiangxi': '江西', 'Anhui': '安徽', 'Shanghai': '上海', 
      'Beijing': '北京', 'Chongqing': '重庆', 'Hainan': '海南', 'Hong Kong': '香港', 'Macao': '澳门', 'Taiwan': '台湾',
      'Liaoning': '辽宁', 'Jilin': '吉林', 'Heilongjiang': '黑龙江',
      'Nei Mongol': '内蒙古', 'Xizang': '西藏', 'Guangxi Zhuang': '广西', 'Ningxia Hui': '宁夏',
      'Hongkong': '香港', 'Macau': '澳门', 'Sichuang': '四川', 'Guangdung': '广东'
    };

    // 数据加载配置
    const DATA_CONFIG = {
      doveDataUrl: 'data/dove-data.json',
      mapDataUrl: 'data/china-provinces.topojson',
      doveBackupUrls: [
        'https://cdn.jsdelivr.net/npm/d3-demo-data@1.0.1/dove-data.json',
        'https://raw.githubusercontent.com/d3/d3-demo-data/master/dove-data.json'
      ],
      mapBackupUrls: [
        'https://raw.githubusercontent.com/zhousiwei/china-topojson/master/china-provinces.json',
        'https://gitee.com/zhousiwei/china-topojson/raw/master/china-provinces.json',
        'https://cdn.jsdelivr.net/gh/zhousiwei/china-topojson/china-provinces.json'
      ]
    };

    // 初始化函数
    async function init() {
      const debugEl = document.getElementById('debug-info');
      debugEl.textContent = '初始化中...';

      try {
        // 1. 加载观测数据
        debugEl.textContent = '正在加载观测数据...';
        const doveRaw = await loadDataWithMultiBackup(
          DATA_CONFIG.doveDataUrl,
          DATA_CONFIG.doveBackupUrls,
          '观测数据'
        );
        
        // 处理数据
        ALL_DATA = processRawData(doveRaw);
        
        // 隐藏加载提示
        document.getElementById('time-loading').style.display = 'none';
        document.getElementById('habitat-loading').style.display = 'none';
        
        debugEl.textContent = `数据加载成功（共${ALL_DATA.length}条有效记录）`;
        
        if (ALL_DATA.length === 0) {
          throw new Error('无有效观测数据，请检查数据格式');
        }

        // 2. 绘制时间图表
        drawTimeCharts();
        // 3. 绘制栖息地图表
        drawHabitatCharts();
      } catch (err) {
        console.error('核心图表错误：', err);
        debugEl.textContent = `数据错误：${err.message}`;
        document.getElementById('time-loading').textContent = '数据加载失败';
        document.getElementById('habitat-loading').textContent = '数据加载失败';
      }

      // 4. 加载并绘制地图
      try {
        debugEl.textContent = '正在加载地图数据...';
        const mapRaw = await loadDataWithMultiBackup(
          DATA_CONFIG.mapDataUrl,
          DATA_CONFIG.mapBackupUrls,
          '地图数据'
        );
        
        // 隐藏地图加载提示
        document.getElementById('map-loading').style.display = 'none';
        
        drawMapChart(mapRaw);
        debugEl.textContent = `地图加载成功（共${ALL_DATA.length}条记录）`;
      } catch (err) {
        console.error('地图错误：', err);
        document.getElementById('map-loading').style.display = 'none';
        document.getElementById('map-error').style.display = 'flex';
        document.getElementById('map-error-text').textContent = `地图错误：${err.message}`;
      }
    }

    // 数据加载函数
    async function loadDataWithMultiBackup(primaryUrl, backupUrls, dataName) {
      const loadSingleUrl = async (url) => {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        if (!data) throw new Error('数据为空');
        return data;
      };

      try { 
        return await loadSingleUrl(primaryUrl); 
      } catch (e) { 
        console.warn('主链接失败，尝试备用...'); 
      }

      for (const url of backupUrls) {
        try { 
          return await loadSingleUrl(url); 
        } catch (e) { 
          console.warn(`备用链接失败: ${url}`); 
          continue; 
        }
      }

      throw new Error(`所有${dataName}链接均失败`);
    }

    // 数据预处理逻辑
    function processRawData(rawData) {
      if (!Array.isArray(rawData)) {
        console.warn('观测数据不是数组格式，生成模拟数据（英文省份名）');
        return generateMockData();
      }

      return rawData
        .filter(d => {
          if (d === null || typeof d !== 'object') return false;

          const year = Number(d.year);
          const month = Number(d.month);
          const count = Number(d.individualCount);

          return !isNaN(year) && !isNaN(month) && !isNaN(count) &&
                 year >= 2015 && year <= 2025 &&
                 month >= 1 && month <= 12 &&
                 count >= 0;
        })
        .map(d => {
          const lat = Number(d.decimalLatitude);
          const lon = Number(d.decimalLongitude);
          
          let provinceCn = '未知省份';
          if (d.stateProvince) {
            provinceCn = PROVINCE_MAP[d.stateProvince] || d.stateProvince || '未知省份';
          }
          
          return {
            ...d,
            individualCount: Math.max(0, Math.floor(Number(d.individualCount))),
            year: Math.floor(Number(d.year)),
            month: Math.floor(Number(d.month)),
            decimalLatitude: !isNaN(lat) ? lat : null,
            decimalLongitude: !isNaN(lon) ? lon : null,
            provinceCn: provinceCn,
            provinceEng: d.stateProvince || 'Unknown',
            locality: d.locality || '未知地点',
            eventDate: d.eventDate || `${d.year}年${d.month}月`,
            habitat: classifyHabitat(d.locality)
          };
        });
    }

    // 生成模拟数据
    function generateMockData() {
      const habitats = ['校园', '湿地/水域', '乡镇居民区', '村庄居民区', '农田/围垦区', '公园/景区', '山地/森林', '其他'];
      const provinceEngList = Object.keys(PROVINCE_MAP);
      
      const data = [];
      for (let year = 2015; year <= 2025; year++) {
        for (let month = 1; month <= 12; month++) {
          const recordsCount = Math.floor(Math.random() * 5) + 1;
          
          for (let i = 0; i < recordsCount; i++) {
            const provinceEng = provinceEngList[Math.floor(Math.random() * provinceEngList.length)];
            const provinceCn = PROVINCE_MAP[provinceEng];
            const habitat = habitats[Math.floor(Math.random() * habitats.length)];
            
            data.push({
              year: year,
              month: month,
              individualCount: Math.floor(Math.random() * 20) + 1,
              decimalLatitude: 20 + Math.random() * 30,
              decimalLongitude: 80 + Math.random() * 50,
              stateProvince: provinceEng,
              locality: `${provinceCn}某${habitat}`,
              habitat: habitat
            });
          }
        }
      }
      
      return data;
    }

    // 栖息地分类
    function classifyHabitat(locality) {
      if (!locality) return '其他';
      locality = locality.trim();
      if (locality.includes('大学') || locality.includes('学院')) return '校园';
      if (locality.includes('湿地') || locality.includes('湖泊') || locality.includes('河流')) return '湿地/水域';
      if (locality.includes('镇') || locality.includes('街道') || locality.includes('城区')) return '乡镇居民区';
      if (locality.includes('村') || locality.includes('庄')) return '村庄居民区';
      if (locality.includes('农田') || locality.includes('耕地')) return '农田/围垦区';
      if (locality.includes('公园') || locality.includes('景区')) return '公园/景区';
      if (locality.includes('山地') || locality.includes('森林')) return '山地/森林';
      return '其他';
    }

    // 工具提示函数
    function showTooltip(event, content) {
      TOOLTIP
        .style('display', 'block')
        .html(content.replace(/\n/g, '<br>'))
        .style('left', (event.pageX + 10) + 'px')
        .style('top', (event.pageY - 10) + 'px');
    }

    function hideTooltip() {
      TOOLTIP.style('display', 'none');
    }

    // 时间趋势图绘制
    function drawTimeCharts() {
      // 1. 年度数据聚合
      const yearGroups = d3.group(ALL_DATA, d => d.year);
      const yearAgg = Array.from(yearGroups.entries())
        .map(([year, items]) => ({
          key: +year,
          value: d3.sum(items, d => d.individualCount)
        }))
        .sort((a, b) => a.key - b.key);

      // 2. 月度数据聚合
      const monthGroups = d3.group(ALL_DATA, d => d.year, d => d.month);
      const monthAgg = Array.from(monthGroups.entries())
        .sort((a, b) => a.key - b.key);

      const years = Array.from({length: 11}, (_, i) => 2015 + i);
      const months = ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'];
      const maxYearCount = yearAgg.length > 0 ? Math.max(...yearAgg.map(d => d.value), 1) : 1;
      const maxMonthCount = monthAgg.length > 0 
        ? d3.max(monthAgg, d => d3.max(Array.from(d[1].values()), v => d3.sum(v, i => i.individualCount)) || 1) 
        : 1;

      // 绘制年度折线图
      const yearSvg = d3.select('#year-trend');
      const yearWidth = yearSvg.node().clientWidth;
      const yearHeight = yearSvg.node().clientHeight;
      const yearMargin = {top: 30, right: 20, bottom: 30, left: 40};
      const yearInnerWidth = yearWidth - yearMargin.left - yearMargin.right;
      const yearInnerHeight = yearHeight - yearMargin.top - yearMargin.bottom;

      yearSvg.selectAll("*").remove();

      const xYear = d3.scaleLinear().domain([2015, 2025]).range([0, yearInnerWidth]);
      const yYear = d3.scaleLinear().domain([0, maxYearCount * 1.1]).range([yearInnerHeight, 0]);

      const lineGenerator = d3.line()
        .x(d => xYear(d.key))
        .y(d => yYear(d.value))
        .curve(d3.curveMonotoneX);

      const yearG = yearSvg.append('g').attr('transform', `translate(${yearMargin.left}, ${yearMargin.top})`);

      if (yearAgg.length > 0) {
        yearG.append('path')
          .attr('d', lineGenerator(yearAgg))
          .attr('fill', 'none')
          .attr('stroke', '#2E86AB')
          .attr('stroke-width', 3);

        yearG.selectAll('circle')
          .data(yearAgg)
          .enter()
          .append('circle')
          .attr('cx', d => xYear(d.key))
          .attr('cy', d => yYear(d.value))
          .attr('r', 4)
          .attr('fill', '#2E86AB')
          .on('mouseover', (e, d) => showTooltip(e, `${d.key}年<br>总个体数：${d.value}只`))
          .on('mouseout', hideTooltip);
      } else {
        yearG.append('text')
          .attr('x', yearInnerWidth / 2)
          .attr('y', yearInnerHeight / 2)
          .attr('text-anchor', 'middle')
          .attr('fill', '#999')
          .text('无年度观测数据');
      }

      yearG.append('g')
        .attr('transform', `translate(0, ${yearInnerHeight})`)
        .attr('class', 'axis')
        .call(d3.axisBottom(xYear).tickFormat(d => d + '年').ticks(11));

      yearG.append('g')
        .attr('class', 'axis')
        .call(d3.axisLeft(yYear).tickFormat(d => d + '只').ticks(6));

      yearG.append('text')
        .attr('x', yearInnerWidth / 2)
        .attr('y', -10)
        .attr('text-anchor', 'middle')
        .attr('fill', '#333')
        .text('年度斑鸠观测总个体数趋势');

      // 绘制月度热力图
      const monthSvg = d3.select('#month-heatmap');
      const monthWidth = monthSvg.node().clientWidth;
      const monthHeight = monthSvg.node().clientHeight;
      const monthMargin = {top: 30, right: 20, bottom: 40, left: 40};
      const monthInnerWidth = monthWidth - monthMargin.left - monthMargin.right;
      const monthInnerHeight = monthHeight - monthMargin.top - monthMargin.bottom;

      monthSvg.selectAll("*").remove();

      const colorScale = d3.scaleSequential()
        .domain([0, maxMonthCount])
        .interpolator(d3.interpolateYlOrRd);

      const cellWidth = monthInnerWidth / 12;
      const cellHeight = monthInnerHeight / 11;

      const monthG = monthSvg.append('g').attr('transform', `translate(${monthMargin.left}, ${monthMargin.top})`);

      const heatmapData = years.flatMap(year => 
        months.map((_, idx) => ({ year, month: idx + 1 }))
      );

      monthG.selectAll('rect')
        .data(heatmapData)
        .enter()
        .append('rect')
        .attr('x', d => (d.month - 1) * cellWidth)
        .attr('y', d => (d.year - 2015) * cellHeight)
        .attr('width', cellWidth - 1)
        .attr('height', cellHeight - 1)
        .attr('fill', d => {
          const yearGroup = monthGroups.get(d.year);
          if (!yearGroup) return colorScale(0);
          const monthItems = yearGroup.get(d.month) || [];
          const count = d3.sum(monthItems, item => item.individualCount);
          return colorScale(count);
        })
        .on('mouseover', (e, d) => {
          const yearGroup = monthGroups.get(d.year);
          const monthItems = yearGroup ? yearGroup.get(d.month) || [] : [];
          const count = d3.sum(monthItems, item => item.individualCount);
          showTooltip(e, `${d.year}年${d.month}月<br>观测个体数：${count}只`);
        })
        .on('mouseout', hideTooltip);

      monthG.append('g')
        .attr('transform', `translate(0, ${monthInnerHeight})`)
        .attr('class', 'axis')
        .selectAll('text')
        .data(months)
        .enter()
        .append('text')
        .attr('x', (d, i) => i * cellWidth + cellWidth / 2)
        .attr('y', 20)
        .attr('text-anchor', 'middle')
        .text(d => d);

      monthG.append('g')
        .attr('class', 'axis')
        .selectAll('text')
        .data(years)
        .enter()
        .append('text')
        .attr('x', -5)
        .attr('y', (d, i) => i * cellHeight + cellHeight / 2)
        .attr('text-anchor', 'end')
        .text(d => d + '年');

      monthG.append('text')
        .attr('x', monthInnerWidth / 2)
        .attr('y', -10)
        .attr('text-anchor', 'middle')
        .attr('fill', '#333')
        .text('月度斑鸠观测数量热力图');
    }

    // 空间分布图绘制 - 完全修复版本
    function drawMapChart(mapRaw) {
      const mapSvg = d3.select('#map-chart');
      const mapWidth = mapSvg.node().clientWidth;
      const mapHeight = mapSvg.node().clientHeight;

      mapSvg.selectAll("*").remove();

      // 1. 聚合省份数据（使用英文省份名聚合）
      const provinceGroups = d3.group(ALL_DATA, d => d.stateProvince);
      const provinceAgg = Array.from(provinceGroups.entries())
        .map(([provinceEng, items]) => {
          const provinceCn = PROVINCE_MAP[provinceEng] || provinceEng;
          return {
            province: provinceCn,
            provinceEng: provinceEng,
            count: items.length,
            totalIndividuals: d3.sum(items, d => d.individualCount),
            avgIndividuals: items.length > 0 ? (d3.sum(items, d => d.individualCount) / items.length).toFixed(1) : '0.0'
          };
        });

      console.log('省份数据聚合结果（英文→中文）：', provinceAgg);

      const maxIndividuals = provinceAgg.length > 0 
        ? Math.max(...provinceAgg.map(d => d.totalIndividuals), 1) 
        : 1;

      // 2. 地图投影
      const projection = d3.geoMercator()
        .center([104.0, 36.0])
        .scale(mapWidth * 0.8)
        .translate([mapWidth / 2, mapHeight / 2]);

      const path = d3.geoPath().projection(projection);

      // 3. 解析地图数据
      let provinces = [];
      try {
        const objectKeys = Object.keys(mapRaw.objects);
        const targetKey = objectKeys.find(k => 
          ['provinces', 'china', 'province', 'boundary'].includes(k.toLowerCase())
        ) || objectKeys[0];
        
        const topoFeature = topojson.feature(mapRaw, mapRaw.objects[targetKey]);
        provinces = topoFeature.features;
      } catch (err) {
        console.error('地图解析错误:', err);
        throw new Error('地图数据格式不正确');
      }

      if (provinces.length === 0) {
        throw new Error('未解析到省份数据');
      }

      // 4. 省份名称获取函数
      function getProvinceName(feature) {
        const nameProps = ['name', 'n', 'province', 'NAME', 'Name', '省名', 'cnname', 'label'];
        let provinceName = '未知';
        
        for (const prop of nameProps) {
          if (feature.properties && feature.properties[prop]) {
            provinceName = feature.properties[prop];
            break;
          }
        }
        
        return provinceName;
      }

      // 5. 省份匹配函数
      function matchProvinceData(provinceName) {
        // 1. 直接匹配
        for (const item of provinceAgg) {
          if (item.province === provinceName) {
            return item;
          }
        }
        
        // 2. 去除后缀后匹配
        const cleanName = provinceName.replace(/省|市|自治区|壮族|维吾尔|回族|蒙古族|藏族|特别行政区/g, '');
        for (const item of provinceAgg) {
          if (item.province === cleanName || item.province.includes(cleanName) || cleanName.includes(item.province)) {
            return item;
          }
        }
        
        // 3. 部分匹配
        for (const item of provinceAgg) {
          if (provinceName.includes(item.province) || item.province.includes(provinceName)) {
            return item;
          }
        }
        
        console.warn(`未找到省份"${provinceName}"的匹配数据`);
        return null;
      }

      // 6. 分析省份边界，检测异常区域
      function analyzeProvinceBounds(provinces) {
  const bounds = {};
  
  provinces.forEach(province => {
    const name = getProvinceName(province);
    const area = path.area(province);
    
    if (!bounds[name]) {
      bounds[name] = { count: 0, totalArea: 0, maxArea: 0, features: [] };
    }
    
    bounds[name].count++;
    bounds[name].totalArea += area;
    bounds[name].maxArea = Math.max(bounds[name].maxArea, area);
    bounds[name].features.push(province);
  });
  
  return bounds;
}

const provinceBounds = analyzeProvinceBounds(provinces);

// 7. 分离有数据和无数据的省份，并过滤异常区域 - 修复版本
const provincesWithData = [];
const provincesWithoutData = [];

// 计算合理的面积阈值（基于正常省份面积）
const allAreas = provinces.map(province => path.area(province)).filter(area => area > 0);
const sortedAreas = allAreas.sort((a, b) => a - b);
// 使用中位数作为参考，过滤掉异常大的区域
const medianArea = sortedAreas[Math.floor(sortedAreas.length / 2)];
const areaThreshold = medianArea * 100; // 阈值设为中位数的10倍

console.log('面积统计:', {
  min: Math.min(...allAreas),
  max: Math.max(...allAreas),
  median: medianArea,
  threshold: areaThreshold
});

provinces.forEach(province => {
  const provinceName = getProvinceName(province);
  const provinceData = matchProvinceData(provinceName);
  const area = path.area(province);
  
  // 改进的过滤逻辑：基于相对面积而非绝对数值
  if (area > areaThreshold) {
    console.warn(`过滤掉异常大区域: ${provinceName} (面积: ${area.toFixed(0)}, 阈值: ${areaThreshold.toFixed(0)})`);
    return;
  }
  
  if (provinceData && provinceData.totalIndividuals > 0) {
    provincesWithData.push(province);
  } else {
    provincesWithoutData.push(province);
  }
});

// 8. 处理被过滤掉的省份：尝试找到它们的正常版本
Object.entries(provinceBounds).forEach(([provinceName, info]) => {
  // 如果这个省份的所有特征都被过滤掉了
  const hasValidFeature = info.features.some(feature => {
    const area = path.area(feature);
    return area <= areaThreshold;
  });
  
  if (!hasValidFeature && info.features.length > 0) {
    // 尝试选择面积最小的特征作为代表
    const validFeatures = info.features.filter(feature => path.area(feature) > 0);
    if (validFeatures.length > 0) {
      const smallestFeature = validFeatures.reduce((min, feature) => 
        path.area(feature) < path.area(min) ? feature : min
      );
      
      const provinceData = matchProvinceData(provinceName);
      const area = path.area(smallestFeature);
      
      if (area <= areaThreshold) {
        console.log(`恢复省份 ${provinceName} 的正常区域 (面积: ${area.toFixed(0)})`);
        
        if (provinceData && provinceData.totalIndividuals > 0) {
          provincesWithData.push(smallestFeature);
        } else {
          provincesWithoutData.push(smallestFeature);
        }
      }
    }
  }
});

      

      console.log(`有数据省份: ${provincesWithData.length}, 无数据省份: ${provincesWithoutData.length}`);

      // 8. 创建颜色比例尺
      const colorScale = d3.scaleSequential()
        .domain([0, maxIndividuals])
        .interpolator(d3.interpolateBlues);

      // 9. 绘制地图容器
      const mapG = mapSvg.append('g');

      // 10. 先绘制无数据的省份（底层）
      const pathsWithoutData = mapG.selectAll('path.province-no-data')
        .data(provincesWithoutData)
        .enter()
        .append('path')
        .attr('class', 'province province-no-data')
        .attr('d', path)
        .attr('fill', '#f0f0f0')
        .attr('stroke', '#ffffff')
        .attr('stroke-width', 0.5)
        .attr('fill-opacity', 0.6)
        .style('pointer-events', 'all');

      // 11. 再绘制有数据的省份（顶层）
      const pathsWithData = mapG.selectAll('path.province-with-data')
        .data(provincesWithData)
        .enter()
        .append('path')
        .attr('class', 'province province-with-data')
        .attr('d', path)
        .attr('fill', d => {
          const provinceName = getProvinceName(d);
          const provinceData = matchProvinceData(provinceName);
          return colorScale(provinceData.totalIndividuals);
        })
        .attr('stroke', '#ffffff')
        .attr('stroke-width', 1)
        .attr('fill-opacity', 0.8)
        .style('pointer-events', 'all');

      // 12. 绑定事件处理函数
      function bindProvinceEvents(selection, hasData = true) {
        selection
          .on('mouseover', function(e, d) {
            e.stopPropagation();
            e.preventDefault();
            
            const provinceName = getProvinceName(d);
            const provinceData = matchProvinceData(provinceName);
            
            console.log(`✅ HOVER: ${provinceName} (有数据: ${hasData})`);
            
            let content;
            if (provinceData && provinceData.totalIndividuals > 0) {
              content = `省份：${provinceData.province}
总观测个体数：${provinceData.totalIndividuals}只
观测次数：${provinceData.count}次
平均每次：${provinceData.avgIndividuals}只`;
            } else {
              content = `省份：${provinceName}
暂无观测数据`;
            }
            
            showTooltip(e, content);
            d3.select(this).attr('fill-opacity', 0.95);
          })
          .on('mouseout', function(e) {
            e.stopPropagation();
            e.preventDefault();
            
            hideTooltip();
            d3.select(this).attr('fill-opacity', hasData ? 0.8 : 0.6);
          })
          .on('click', function(e, d) {
            e.stopPropagation();
            e.preventDefault();
            const provinceName = getProvinceName(d);
            console.log(`点击省份: ${provinceName}`);
          });
      }

      // 绑定事件
      bindProvinceEvents(pathsWithData, true);
      bindProvinceEvents(pathsWithoutData, false);

      // 13. 绘制观测点
      const validPoints = ALL_DATA.filter(d => {
        if (!d.decimalLatitude || !d.decimalLongitude) return false;
        const [x, y] = projection([d.decimalLongitude, d.decimalLatitude]);
        return !isNaN(x) && !isNaN(y) && x >= 0 && x <= mapWidth && y >=0 && y <= mapHeight;
      });

      const observationPoints = mapG.selectAll('circle.observation-point')
        .data(validPoints)
        .enter()
        .append('circle')
        .attr('class', 'observation-point')
        .attr('cx', d => projection([d.decimalLongitude, d.decimalLatitude])[0])
        .attr('cy', d => projection([d.decimalLongitude, d.decimalLatitude])[1])
        .attr('r', d => Math.max(2, Math.sqrt(d.individualCount) * 1.2))
        .attr('fill', '#FF6B6B')
        .attr('opacity', 0.7);

      observationPoints.each(function() {
        const point = d3.select(this);
        const originalR = point.attr('r');
        point.datum().originalR = originalR;
      });

      observationPoints
        .on('mouseover', (e, d) => {
          showTooltip(e, `地点：${d.locality}
时间：${d.eventDate}
数量：${d.individualCount}只
省份：${d.provinceCn}`);
          d3.select(e.currentTarget)
            .attr('opacity', 0.9)
            .attr('r', parseFloat(d.originalR) + 1);
        })
        .on('mouseout', (e, d) => {
          hideTooltip();
          d3.select(e.currentTarget)
            .attr('opacity', 0.7)
            .attr('r', d.originalR);
        });

      // 14. 绘制图例
      const defs = mapSvg.append('defs');
      const gradient = defs.append('linearGradient')
        .attr('id', 'color-gradient')
        .attr('x1', '0%')
        .attr('y1', '100%')
        .attr('x2', '0%')
        .attr('y2', '0%');

      gradient.selectAll('stop')
        .data(d3.range(0, 1.01, 0.1))
        .enter()
        .append('stop')
        .attr('offset', d => `${d * 100}%`)
        .attr('stop-color', d => colorScale(d * maxIndividuals));

      const legendG = mapSvg.append('g')
        .attr('transform', `translate(${mapWidth - 60}, ${(mapHeight - 250) / 2})`);

      legendG.append('rect')
        .attr('width', 20)
        .attr('height', 250)
        .attr('fill', 'url(#color-gradient)')
        .attr('stroke', '#ddd')
        .attr('stroke-width', 0.5);

      legendG.append('g')
        .attr('transform', `translate(30, 0)`)
        .attr('class', 'axis')
        .call(d3.axisRight(d3.scaleLinear()
          .domain([0, maxIndividuals])
          .range([250, 0]))
          .tickFormat(d => d + '只')
          .ticks(5));

      legendG.append('text')
        .attr('x', 10)
        .attr('y', -10)
        .attr('text-anchor', 'middle')
        .attr('fill', '#333')
        .attr('font-size', 12)
        .text('省份总观测数');

      // 15. 添加调试信息
      console.log('=== 地图绘制完成 ===');
      console.log(`有数据省份数量: ${provincesWithData.length}`);
      console.log(`无数据省份数量: ${provincesWithoutData.length}`);
      console.log(`观测点数量: ${validPoints.length}`);
    }

    // 栖息地类型分析
    function drawHabitatCharts() {
      const habitatAggMap = d3.rollup(
        ALL_DATA,
        v => ({
          totalIndividuals: d3.sum(v, d => d.individualCount) || 0,
          observationTimes: v.length || 0,
          avgIndividuals: v.length > 0 ? d3.mean(v, d => d.individualCount).toFixed(1) : '0.0'
        }),
        d => d.habitat
      );

      const habitatAgg = Array.from(habitatAggMap.entries())
        .filter(([_, value]) => value.totalIndividuals > 0)
        .sort((a, b) => b[1].totalIndividuals - a[1].totalIndividuals);

      if (habitatAgg.length === 0) {
        throw new Error('无有效栖息地数据');
      }

      const totalIndividuals = d3.sum(habitatAgg, ([_, value]) => value.totalIndividuals) || 1;

      // 绘制条形图
      const barSvg = d3.select('#habitat-bar');
      const barWidth = barSvg.node().clientWidth;
      const barHeight = barSvg.node().clientHeight;
      const barMargin = {top: 40, right: 30, bottom: 40, left: 80};
      const barInnerWidth = barWidth - barMargin.left - barMargin.right;
      const barInnerHeight = barHeight - barMargin.top - barMargin.bottom;

      barSvg.selectAll("*").remove();

      const xBar = d3.scaleLinear()
        .domain([0, d3.max(habitatAgg, ([_, value]) => value.totalIndividuals) * 1.1])
        .range([0, barInnerWidth]);

      const yBar = d3.scaleBand()
        .domain(habitatAgg.map(([key]) => key))
        .range([0, barInnerHeight])
        .padding(0.15);

      const barG = barSvg.append('g').attr('transform', `translate(${barMargin.left}, ${barMargin.top})`);

      barG.selectAll('rect')
        .data(habitatAgg)
        .enter()
        .append('rect')
        .attr('x', 0)
        .attr('y', ([key]) => yBar(key))
        .attr('width', ([_, value]) => xBar(value.totalIndividuals))
        .attr('height', yBar.bandwidth())
        .attr('fill', '#A23B72')
        .attr('fill-opacity', 0.8)
        .on('mouseover', (e, [key, value]) => {
          const content = `类型：${key}<br>总个体数：${value.totalIndividuals}只<br>观测次数：${value.observationTimes}次<br>平均每次：${value.avgIndividuals}只`;
          showTooltip(e, content);
        })
        .on('mouseout', hideTooltip);

      barG.selectAll('text.value')
        .data(habitatAgg)
        .enter()
        .append('text')
        .attr('class', 'value')
        .attr('x', ([_, value]) => xBar(value.totalIndividuals) + 5)
        .attr('y', ([key]) => yBar(key) + yBar.bandwidth() / 2)
        .attr('alignment-baseline', 'middle')
        .attr('fill', '#333')
        .attr('font-size', 11)
        .text(([_, value]) => value.totalIndividuals + '只');

      barG.append('g')
        .attr('transform', `translate(0, ${barInnerHeight})`)
        .attr('class', 'axis')
        .call(d3.axisBottom(xBar).tickFormat(d => d + '只').ticks(6));

      barG.append('g')
        .attr('class', 'axis')
        .call(d3.axisLeft(yBar).tickSize(0))
        .selectAll('text')
        .attr('fill', '#333')
        .attr('font-size', 12);

      // 绘制饼图
      const pieSvg = d3.select('#habitat-pie');
      const pieSize = Math.min(pieSvg.node().clientWidth, pieSvg.node().clientHeight) - 80;
      const pieRadius = pieSize / 2;

      pieSvg.selectAll("*").remove();

      const pieG = pieSvg.append('g')
        .attr('transform', `translate(${pieSvg.node().clientWidth / 2}, ${pieSvg.node().clientHeight / 2})`);

      const pieColor = d3.scaleOrdinal()
        .domain(habitatAgg.map(([key]) => key))
        .range(d3.schemeSet3);

      const pie = d3.pie()
        .value(([_, value]) => value.totalIndividuals)
        .sort(null);

      const arc = d3.arc()
        .innerRadius(pieRadius * 0.4)
        .outerRadius(pieRadius);

      pieG.selectAll('path')
        .data(pie(habitatAgg))
        .enter()
        .append('path')
        .attr('d', arc)
        .attr('fill', d => pieColor(d.data[0]))
        .attr('stroke', '#ffffff')
        .attr('stroke-width', 1.5)
        .on('mouseover', (e, d) => {
          const [key, value] = d.data;
          const percentage = ((value.totalIndividuals / totalIndividuals) * 100).toFixed(1);
          const content = `${key}<br>占比：${percentage}%<br>总个体数：${value.totalIndividuals}只`;
          showTooltip(e, content);
        })
        .on('mouseout', hideTooltip);

      // 饼图图例
      const legendG = pieSvg.append('g')
        .attr('transform', `translate(${pieSvg.node().clientWidth / 2}, ${pieSvg.node().clientHeight - 20})`);

      const legendPerRow = Math.min(habitatAgg.length, 4);
      const legendItems = legendG.selectAll('g')
        .data(habitatAgg)
        .enter()
        .append('g')
        .attr('transform', (_, i) => {
          const row = Math.floor(i / legendPerRow);
          const col = i % legendPerRow;
        .attr('width', 12)
        .attr('height', 12)
        .attr('fill', d => pieColor(d[0]))
        .attr('rx', 2);

      legendItems.append('text')
        .attr('x', 18)
        .attr('y', 12)
        .attr('alignment-baseline', 'middle')
        .attr('fill', '#333')
        .attr('font-size', 11)
        .text(([key, value]) => {
          const percentage = ((value.totalIndividuals / totalIndividuals) * 100).toFixed(1);
          return `${key}(${percentage}%)`;
        });
    }

    // 页面加载完成后初始化
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>